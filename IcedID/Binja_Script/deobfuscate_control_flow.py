
import binaryninja
from binaryninja import *
import binaryninja as bn

# def get_previous_instruction_to_nop(instr):
#     for bb in f.lifted_il:
#         previous_addr = None
#         for i in bb:
#             if i.address == instr.address:
#                 return previous_addr
#             previous_addr = i.address


def handle_cmp_same_regs(instr):
    if instr.operation == LowLevelILOperation.LLIL_IF:
        comparison_statement = instr.operands[0]
        print("Operation : ", comparison_statement.operation)
        print(hex(instr.address))
        try:
            left_comparator = comparison_statement.left
            right_comparator = comparison_statement.right
            false_instr = instr.false
            true_instr = instr.true
        except:
            print("Skipping instruction " , instr , "@",  hex(instr.address))
            return False
    
        if hasattr(left_comparator, 'src') == False or hasattr(right_comparator, 'src') == False:
            return False
        
        # Testing agains the following
        """
        LLIL_CMP_NE - not equal
        LLIL_CMP_SLT - signed less than
        LLIL_CMP_ULT - unsigned less than
        LLIL_CMP_SLE - signed less than or equal
        LLIL_CMP_ULE - unsigned less than or equal
        LLIL_CMP_SGE - signed greater than or equal
        LLIL_CMP_UGE - unsigned greater than or equal
        LLIL_CMP_SGT - signed greater than
        LLIL_CMP_UGT - unsigned greater than
        """
        if left_comparator.src == right_comparator.src and right_comparator.operation == LowLevelILOperation.LLIL_REG and left_comparator.operation == LowLevelILOperation.LLIL_REG:
            if comparison_statement.operation == LowLevelILOperation.LLIL_CMP_E:
                print(hex(instr.address), " -> " , instr.medium_level_il)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                patch_locations.append((instr.address, 1))
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_NE:
                print(hex(instr.address), " -> " , instr.medium_level_il)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                patch_locations.append((instr.address,0))
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_SLE:
                patch_locations.append(instr.address, 1)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_UGE:
                patch_locations.append(instr.address,1)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_ULE:
                patch_locations.append(instr.address,1)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_SGE:
                patch_locations.append(instr.address,1)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_SGT:
                patch_locations.append(instr.address,0)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_UGT:
                patch_locations.append(instr.address,0)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_SLT:
                patch_locations.append(instr.address,0)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            elif comparison_statement.operation == LowLevelILOperation.LLIL_CMP_ULT:
                patch_locations.append(instr.address,0)
                prev_addr = instr.address-3
                previous_locations.append(prev_addr)
                return True
            return False

for f in bv.functions:
    func = f.low_level_il
    patch_locations = []
    previous_locations = []

    for bb in func:
        for instr in bb:
            if handle_cmp_same_regs(instr):
                print()
    for i in patch_locations:
        if i[1] == 1 and bv.is_always_branch_patch_available(i[0]):
            bv.always_branch(i[0])
        elif i[1] == 0 and bv.is_always_branch_patch_available(i[0]):
            bv.never_branch(i[0])














